import asyncio
import concurrent.futures
from flask import Flask, request, jsonify, render_template, session, Response
from parsers import gudvin, promispb, hozka, artplast, newpackspb
from services.image_cache import async_get_cached_image
from flask_caching import Cache
import logging

app = Flask(__name__)
app.secret_key = 'your-secret-key'
cache = Cache(app, config={'CACHE_TYPE': 'SimpleCache', 'CACHE_DEFAULT_TIMEOUT': 300})

# Настройка логирования с форматированием
app.logger.setLevel(logging.DEBUG)
handler = logging.FileHandler('app_debug.log')
handler.setLevel(logging.DEBUG)
formatter = logging.Formatter('%(asctime)s %(levelname)s: %(message)s [in %(pathname)s:%(lineno)d]')
handler.setFormatter(formatter)
app.logger.addHandler(handler)

app.logger.debug("Тестовое сообщение. Логирование настроено правильно.")

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/cart')
def cart():
    return render_template('cart.html')

# Функция проверки, является ли новый запрос уточнением базового:
def is_refinement(new_query, base_query):
    new_tokens = new_query.lower().split()
    base_tokens = base_query.lower().split()
    return len(new_tokens) > len(base_tokens) and all(token in new_tokens for token in base_tokens)

# Асинхронная функция для параллельного запуска парсеров
async def run_parsers(query, stores):
    loop = asyncio.get_event_loop()
    tasks = {store: loop.run_in_executor(None, func, query)
             for store, func in stores.items()}
    results_list = await asyncio.gather(*tasks.values(), return_exceptions=True)
    results = {
        store: result if not isinstance(result, Exception) else []
        for store, result in zip(tasks.keys(), results_list)
    }
    return results
  
@app.route('/api/search', methods=['POST'])
def api_search():
    data = request.get_json()
    query = data.get("query", "").strip()
    if not query:
        return jsonify({"error": "Пустой запрос"}), 400

    # Формируем ключ для кэша
    cache_key = f"search:{query.lower()}"
    cached_results = cache.get(cache_key)
    if cached_results is not None:
        app.logger.debug("Найден результат в кэше для запроса: %s", query)
        session["last_query"] = query
        session["last_cache_key"] = cache_key
        return jsonify(cached_results)

    last_query = session.get("last_query")
    last_cache_key = session.get("last_cache_key")
    last_results = cache.get(last_cache_key) if last_cache_key else None

    app.logger.debug("Сессия - last_query: %s", last_query)
    if last_results:
        app.logger.debug("Сессия - количество товаров: %s", {store: len(prod) for store, prod in last_results.items()})
    
    if last_query and last_results and is_refinement(query, last_query):
        new_tokens = query.lower().split()
        base_tokens = last_query.lower().split()
        app.logger.debug("Проверка уточнения запроса:")
        app.logger.debug("  Last query: %s", last_query)
        app.logger.debug("  New query: %s", query)
        app.logger.debug("  Tokens new: %s", new_tokens)
        app.logger.debug("  Tokens base: %s", base_tokens)
        app.logger.debug("  is_refinement: %s", is_refinement(query, last_query))
        
        refined_results = {}
        for store, products in last_results.items():
            refined_products = []
            for product in products:
                product_name = product.get("name", "").lower()
                if all(token in product_name for token in new_tokens):
                    refined_products.append(product)
            refined_results[store] = refined_products
        
        app.logger.debug("После фильтрации, результаты: %s", {store: len(lst) for store, lst in refined_results.items()})
        
        if sum(len(lst) for lst in refined_results.values()) == 0:
            app.logger.debug("Фильтрация по уточняющему запросу дала пустой результат. Выполняем полный парсинг для запроса: %s", query)
            stores = {
                "gudvin": gudvin.parse_gudvin,
                "promispb": promispb.parse_promispb,
                "hozka": hozka.parse_hozka,
                "artplast": artplast.parse_artplast,
                "newpackspb": newpackspb.parse_newpackspb
            }
            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)
            try:
                refined_results = loop.run_until_complete(run_parsers(query, stores))
                app.logger.debug("Новый поиск для '%s' дал результаты: %s", query, {store: len(lst) for store, lst in refined_results.items()})
            except Exception as e:
                refined_results = {}
                app.logger.error("Async parser error: %s", e)
            finally:
                loop.close()
        
        cache.set(cache_key, refined_results)
        session["last_query"] = query
        session["last_cache_key"] = cache_key
        return jsonify(refined_results)

    stores = {
        "gudvin": gudvin.parse_gudvin,
        "promispb": promispb.parse_promispb,
        "hozka": hozka.parse_hozka,
        "artplast": artplast.parse_artplast,
        "newpackspb": newpackspb.parse_newpackspb
    }
    
    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)
    try:
        results = loop.run_until_complete(run_parsers(query, stores))
        app.logger.debug("Результаты нового парсинга получены.")
    except Exception as e:
        results = {}
        app.logger.error("Async parser error: %s", e)
    finally:
        loop.close()

    cache.set(cache_key, results)
    session["last_query"] = query
    session["last_cache_key"] = cache_key
    app.logger.debug("Сохранены результаты нового парсинга в кэш и обновлены данные сессии для запроса: %s", query)
    return jsonify(results)

@app.route('/cached_image')
def cached_image():
    image_url = request.args.get("url")
    if not image_url:
        return "URL изображения не передан", 400

    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)
    image_bytes = loop.run_until_complete(async_get_cached_image(image_url))
    loop.close()

    if image_bytes:
        return Response(image_bytes, mimetype="image/png")
    else:
        return "Ошибка загрузки изображения", 500

@app.route('/api/cart', methods=['GET'])
def get_cart():
    cart = session.get("cart", [])
    return jsonify(cart)

@app.route('/api/cart/add', methods=['POST'])
def cart_add():
    data = request.get_json()
    product = data.get("product")
    if not product or not product.get("link"):
        return jsonify({"error": "Нет данных о продукте или неопределён идентификатор товара"}), 400

    try:
        step = product.get("step")
        if step is None:
            step = 1
        else:
            try:
                step = int(step)
                if step <= 0:
                    step = 1
            except (ValueError, TypeError):
                step = 1

        quantity = product.get("quantity", step)
        try:
            quantity = int(quantity)
        except (ValueError, TypeError):
            quantity = step

        if quantity < step:
            quantity = step

        cart = session.get("cart", [])
        updated = False
        for item in cart:
            if item.get("link") == product.get("link"):
                item["quantity"] += quantity
                updated = True
                break

        if not updated:
            product["quantity"] = quantity
            product["step"] = step
            cart.append(product)

        session["cart"] = cart
        return jsonify({"message": "Товар добавлен в корзину", "cart": cart})
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/api/cart/remove', methods=['POST'])
def cart_remove():
    data = request.get_json()
    product_link = data.get("link")
    if not product_link:
        return jsonify({"error": "Не задан идентификатор товара"}), 400
    cart = session.get("cart", [])
    cart = [item for item in cart if item.get("link") != product_link]
    session["cart"] = cart
    return jsonify({"message": "Товар удалён из корзины", "cart": cart})

@app.route('/api/cart/update', methods=['POST'])
def cart_update():
    data = request.get_json()
    product_link = data.get("link")
    new_quantity = data.get("quantity")
    if not product_link or new_quantity is None:
        return jsonify({"error": "Необходимо задать идентификатор товара и новое количество"}), 400
    cart = session.get("cart", [])
    for item in cart:
        if item.get("link") == product_link:
            item["quantity"] = new_quantity
            break
    session["cart"] = cart
    return jsonify({"message": "Корзина обновлена", "cart": cart})

@app.route('/api/cart/checkout', methods=['POST'])
def cart_checkout():
    cart = session.get("cart", [])
    if not cart:
        return jsonify({"error": "Ваша корзина пуста"}), 400
    session["cart"] = []
    return jsonify({"message": "Заказ оформлен, спасибо!", "cart": []})

# Новый маршрут для очистки всей корзины
@app.route('/api/cart/clear_all', methods=['POST'])
def clear_cart_all():
    session["cart"] = []
    return jsonify({"message": "Вся корзина очищена", "cart": []})

# Новый маршрут для очистки корзины в конкретной группе
@app.route('/api/cart/clear_group', methods=['POST'])
def clear_cart_group():
    data = request.get_json()
    supplier = data.get("store")
    if not supplier:
        return jsonify({"error": "Не указан поставщик"}), 400
    cart = session.get("cart", [])
    new_cart = [item for item in cart if item.get("store") != supplier]
    session["cart"] = new_cart
    return jsonify({"message": f"Корзина для поставщика {supplier} очищена", "cart": new_cart})

if __name__ == '__main__':
    app.run(debug=True)
